<h1>Algorithm</h1>

<p>Gecko orders the nodes of an undirected and optionally weighted graph in an
effort to place nodes connected by an edge in consecutive positions in the
linear ordering (aka. <em>layout</em>).  Such orderings promote good data locality,
e.g., to improve cache utilization, but also find applications in graph
partitioning and dimensionality reduction.</p>

<p>The gecko ordering method is inspired by algebraic multigrid methods, and
uses V-cycles to coarsen, optimize, and refine the graph layout.
The graph constitutes an abstract representation of the relationship
between elements in a data set, e.g., a graph node may represent a
vertex or a cell in a mesh, a pixel in an image, a node in a binary
search tree, an element in a sparse matrix, etc.  The graph edges
represent node affinities, or a desire that adjacent nodes be stored
close together on linear storage (e.g., disk or main memory).  Such a
data layout is likely to improve cache utilization in block-based
caches common on today's computer architectures.  For instance, the
edges may connect adjacent pixels in an image, as many image
processing operations involve accessing local neighborhoods.  The
resulting node layouts are "cache-oblivious," in the sense that no
particular knowledge of the cache parameters (number and size of
blocks, associativity, replacement policy, etc.) are accounted for.
Rather, the expectation is that the layouts will provide good
locality across all levels of cache.  Note that the ordering method
accepts any undirected graph, whether it represent a structured or
unstructured data set, and is also oblivious of any geometric
structure inherent in the data set.</p>

<p>The optimization algorithm attempts to order the nodes of the graph
so as to minimize the geometric mean edge length, or equivalently
the product</p>

<pre><code>product |p(i) - p(j)|^w(i, j)
</code></pre>

<p>or weighted sum</p>

<pre><code>sum w(i, j) log(|p(i) - p(j)|)
</code></pre>

<p>where <em>i</em> and <em>j</em> are nodes joined by an edge, <em>w</em>(<em>i</em>, <em>j</em>) is a positive
edge weight (equal to one unless otherwise specified), <em>p</em>(<em>i</em>) is
the integer position of node <em>i</em> in the linear layout of the graph
(with <em>p</em>(<em>i</em>) = <em>p</em>(<em>j</em>) if and only if <em>i</em> = <em>j</em>), and where the product
or sum is over all edges of the graph.</p>

<p>The algorithm is described in further detail in the paper</p>

<ul>
<li>Peter Lindstrom
<a href="https://www.researchgate.net/publication/259383744_The_Minimum_Edge_Product_Linear_Ordering_Problem">The Minimum Edge Product Linear Ordering Problem</a>
LLNL technical report LLNL-TR-496076, August 26, 2011</li>
</ul>

<h2>Ordering Parameters</h2>

<p>The <code>Graph::order()</code> function and the <code>gecko</code> command-line executable take a
number of parameters that govern the layout process.  These parameters are
described below:</p>

<ul>
<li><p>The <strong>functional</strong> is the objective being optimized and expresses the cost
of the graph layout in terms of some average of its edge lengths
|<em>p</em>(<em>i</em>) - <em>p</em>(<em>j</em>)|.  The predefined functionals are</p>

<ul>
<li><code>h</code> (harmonic mean)</li>
<li><code>g</code> (geometric mean)</li>
<li><code>s</code> (square mean root)</li>
<li><code>a</code> (arithmetic mean)</li>
<li><code>r</code> (root mean square)</li>
<li><code>m</code> (maximum)</li>
</ul>

<p><p>Note that the algorithm has not been well tuned or tested to optimize
functionals other than the geometric mean.</p></li>
<li><p>The number of <strong>iterations</strong> specifies the number of multigrid V-cycles
to perform.  Usually a handful of cycles is sufficient.  The default is
a single cycle.</p></li>
<li><p>The optimization <strong>window</strong> is the number of consecutive nodes optimized
concurrently using exhaustive search.  The larger the window, the higher
the quality.  Note that the running time increases exponentially with the
window size.  Usually a window no larger than six nodes is sufficient.
The default is a window size of two nodes.</p></li>
<li><p>The <strong>period</strong> is the number of V-cycles to run between increments of the
window size.  Usually it is beneficial to start with a small window to get
a rough layout, and to then increase the window size to fine-tune the
layout.  The default is a period of one cycle.</p></li>
<li><p>The random <strong>seed</strong> allows injecting some randomness in the optimization
process.  When the seed is nonzero, the nodes are randomly shuffled prior
to invoking the ordering algorithm, thereby affecting subsequent coarsening
and ordering decisions.  In effect, this randomization allows different
directions to be explored in the combinatorial optimization space.  Fixing
the seed allows for reproducibility, i.e., the same seed always leads to
the same layout.  Since the global optimum is seldom (if ever) reached,
it often makes sense to run several instances of the algorithm, each with
a new random seed, and to pick the best layout found.  In the gecko
executable, the current time is used as random seed if not specified.</p></li>
<li><p>The <strong>psfile</strong> parameter (executable only) is the name of an optional
PostScript file that shows the linear node order on each level of
refinement.  This capability is useful for debugging the ordering of
small graphs.</p></li>
</ul>
A reasonable parameter choice for good-quality layouts is:</p>

<ul>
<li>iterations = 4</li>
<li>window = 4</li>
<li>period = 2</li>
</ul>

<p>As the window gets progressively larger, the running time of each cycle will
rapidly increase.  For this reason, the code can be terminated early via
CTRL-C, at which point the best
layout found so far is output.  The objective function f and the
lowest f found so far are output at the end of each cycle to provide
feedback on progress.  The f value of the input layout is also output
before the first cycle.</p>
