#include <cstddef>
#include <stdexcept>
#include "subgraph.h"

using namespace Gecko;

// Constructor.
Subgraph::Subgraph(Graph* g, uint n) : g(g), n(n), f(g->functional)
{
  if (n > GECKO_WINDOW_MAX)
    throw std::out_of_range("optimization window too large");
  cache = new Subnode[n << n];
}

// Cost of k'th node's edges to external nodes and nodes at {k+1, ..., n-1}.
WeightedSum
Subgraph::cost(uint k) const
{
  Subnode::Index i = perm[k];
  WeightedSum c = node[i]->cost;
  Float p = node[i]->pos;
#if GECKO_WITH_ADJLIST
  for (k = 0; adj[i][k] != i; k++) {
    Subnode::Index j = adj[i][k];
    Float l = node[j]->pos - p;
    if (l > 0) {
      Float w = weight[i][k];
      f->accumulate(c, WeightedValue(l, w));
    }
  }
#else
  uint m = adj[i];
  while (++k < n) {
    Subnode::Index j = perm[k];
    if (m & (1u << j)) {
      Float l = node[j]->pos - p;
      Float w = weight[i][j];
      f->accumulate(c, WeightedValue(l, w));
    }
  }
#endif
  return c;
}

// Swap the two nodes in positions k and k + 1.
void
Subgraph::swap(uint k)
{
  uint l = k + 1;
  Subnode::Index i = perm[k];
  Subnode::Index j = perm[l];
  perm[k] = j;
  perm[l] = i;
  node[i] -= ptrdiff_t(1) << j;
  node[j] += ptrdiff_t(1) << i;
}

// Swap the two nodes in positions k and l, k <= l.
void
Subgraph::swap(uint k, uint l)
{
  Subnode::Index i = perm[k];
  Subnode::Index j = perm[l];
  perm[k] = j;
  perm[l] = i;
  // Update node positions.
  uint m = 0;
  while (++k < l) {
    Subnode::Index h = perm[k];
    node[h] += ptrdiff_t(1) << i;
    node[h] -= ptrdiff_t(1) << j;
    m += 1u << h;
  }
  node[i] -= (1u << j) + m;
  node[j] += (1u << i) + m;
}

#if GECKO_WITH_NONRECURSIVE
// Evaluate all permutations generated by Heap's nonrecursive algorithm.
void
Subgraph::optimize()
{
  WeightedSum c[GECKO_WINDOW_MAX + 1];
  uint j[GECKO_WINDOW_MAX + 1];
  Float min = GECKO_FLOAT_MAX;
  j[n] = 1;
  c[n] = 0;
  uint i = n;
  do {
    i--;
    j[i] = i;
loop:
    c[i] = f->sum(c[i + 1], cost(i));
  } while (i);
  if (f->less(*c, min)) {
    min = *c;
    for (uint k = 0; k < n; k++)
      best[k] = perm[k];
  }
  do {
    if (++i == n)
      return;
    swap(i & 1 ? i - j[i] : 0, i);
  } while (!j[i]--);
  goto loop;
}
#else
// Apply branch-and-bound to permutations generated by Heap's algorithm.
void
Subgraph::optimize(WeightedSum c, uint i)
{
  i--;
  if (f->less(c, min)) {
    if (i) {
      uint j = i;
      do {
        optimize(f->sum(c, cost(i)), i);
        swap(i & 1 ? i - j : 0, i);
      } while (j--);
    }
    else {
      f->accumulate(c, cost(0));
      if (f->less(c, min)) {
        min = c;
        for (uint j = 0; j < n; j++)
          best[j] = perm[j];
      }
    }
  }
  else if (i & 1)
    do swap(--i); while (i);
}
#endif

// Optimize layout of nodes {p, ..., p + n - 1}.
void
Subgraph::optimize(uint p)
{
  // Initialize subgraph.
  const Float q = g->node[g->perm[p]].pos - g->node[g->perm[p]].hlen;
  min = WeightedSum(GECKO_FLOAT_MAX, 1);
  for (Subnode::Index k = 0; k < n; k++) {
    best[k] = perm[k] = k;
    Node::Index i = g->perm[p + k];
    // Copy i's outgoing arcs.  We distinguish between internal
    // and external arcs to nodes within and outside the subgraph,
    // respectively.
#if GECKO_WITH_ADJLIST
    uint m = 0;
#else
    adj[k] = 0;
#endif
    std::vector<Arc::Index> external;
    for (Arc::Index a = g->node_begin(i); a < g->node_end(i); a++) {
      Node::Index j = g->adj[a];
      Subnode::Index l;
      for (l = 0; l < n && g->perm[p + l] != j; l++);
      if (l == n)
        external.push_back(a);
      else {
        // Copy internal arc to subgraph.
#if GECKO_WITH_ADJLIST
        adj[k][m] = l;
        weight[k][m] = g->weight[a];
        m++;
#else
        adj[k] += 1u << l;
        weight[k][l] = g->weight[a];
#endif
      }
    }
#if GECKO_WITH_ADJLIST
    adj[k][m] = k;
#endif
    // Precompute external costs associated with all possible positions
    // of this node.  Since node lengths can be arbitrary, there are as
    // many as 2^(n-1) possible positions, each corresponding to an
    // (n-1)-bit string that specifies whether the remaining n-1 nodes
    // succeed this node or not.  Caching the
    //                n
    //   2^(n-1) n = sum k C(n, k) = A001787
    //               k=1
    // external costs is exponentially cheaper than recomputing the
    //      n-1         n
    //   n! sum 1/k! = sum k! C(n, k) = A007526
    //      k=0        k=1
    // costs associated with all permutations.
    node[k] = cache + (k << n);
    for (uint m = 0; m < (1u << n); m++)
      if (!(m & (1u << k))) {
        Subnode* s = cache + (k << n) + m;
        s->pos = q + g->node[i].hlen;
        for (Subnode::Index l = 0; l < n; l++)
          if (l != k && !(m & (1u << l)))
            s->pos += 2 * g->node[g->perm[p + l]].hlen;
        s->cost = g->cost(external, s->pos);
      }
      else
        m += (1u << k) - 1;
    node[k] += (1u << n) - (2u << k);
  }

  // Find optimal permutation of the n nodes.
  optimize(0, n);

  // Apply permutation to original graph.
  for (uint i = 0; i < n; i++) {
    g->swap(p + i, p + best[i]);
    for (uint j = i + 1; j < n; j++)
      if (best[j] == i)
        best[j] = best[i];
  }
}
